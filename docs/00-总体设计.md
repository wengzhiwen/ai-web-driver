# 总体描述

## 1 目标
- 免代码：QA 通过自然语言/表单即可编写用例。
- 低成本：运行期全本地；仅在“编译/标定”阶段按需使用外部 LLM。
- 可回放：失败可一键回溯（Trace Viewer），定位问题无需复现现场。
- 可维护：站点 Profile（页面/元素/别名/跳转条件）集中管理与版本化。

## 2 非目标（当前阶段）
- 不做“自治代理式”运行期决策（运行期不让 LLM 介入）。
- 不做跨站泛化爬测；只服务被测站点（白名单域）。

## 3 核心数据流
```
TestRequest(自然语言/DSL)
        │
        ├──[编译器/LLM]──► ActionPlan(强类型 DSL JSON)
        │
SiteProfile(标定/别名/定位器) 

ActionPlan ─────────► [执行器/Playwright MCP]
                                   │
                   Trace.zip + 运行明细(SQLite/Artifacts)
                                   │
                         [报告查看器/Trace Viewer]
```

## 4 关键技术选择
- 执行：Playwright。
- 标定：Chrome 插件（侧边面板 + Overlay）原地采集 DOM 指纹与候选选择器，必要时结合 Playwright Inspector / axe 做校验。
- 模型：本地 7B（备用）；外部 LLM “辅助标定/用例编译”。
- 存储：SQLite / JSON文件（Profile/运行结果/工件索引）。

## 5 安全/合规
- Trace/日志：记录所有操作轨迹，便于问题回溯
- 数据隐私：本地存储，不涉及敏感数据外传
- 访问控制：仅限白名单域名访问

## 模块一：标定工具（Profile Builder）

### 1 核心功能
- Chrome 插件标注模式：Alt+P 快捷键切换，覆盖层实时高亮 `elementFromPoint` 命中的节点，点击即记录标注项。
- 侧边面板：展示当前标签页的 DOM 快照，支持 Frame 切换、关键字搜索、节点折叠；单击高亮、双击加入标注。
- 标注数据：自动采集标准化 URL、节点指纹（tag/id/data-testid/aria/title/value/placeholder/text）、候选选择器列表、结构化 `cssPath`、元素矩形信息。
- 本地持久化：按页面 URL 分组存储于 `chrome.storage.local`，侧边面板即可管理增删改。
- Site Profile 导出：通过 `chrome.downloads` 一键生成符合项目 schema 的 JSON 文件，含 `bestSelector` 与候选列表。
- 体验增强：智能节点过滤（排除 script/style 等），DOM 懒加载上限约 2000 节点，并行处理多 Frame，确保大型页面也能流畅标注。

### 2 SiteProfile
- 标定工具的核心输出是标定结果 SiteProfile
- SiteProfile是对被测试站点中的被测试对象页面的一系列描述
- 后续的编译器总是基于SiteProfile来对用户的自然语言用例描述进行处理（处理成Playwright指令和断言）
- SiteProfile是自带版本管理的，当SiteProfile中如果发生变化，与变化相关的页面及SiteProfile本身的版本号都会发生变化
- 插件导出的 SiteProfile 会记录首选选择器与候选列表，后续执行器可直接消费并在需要时回写更优选择器
- 隐藏操作会被准确的记录在SiteProfile的专门位置，被隐藏的DOM不会出现在SiteProfile的核心数据中，因为这些信息不需要被送给后续的编译器（编译器依赖LLM，送去的噪音越少越好）

### 3 SiteProfile的保存和调取
- SiteProfile应该被保存为结构化的JSON文件
- Chrome 插件支持本地缓存增量修改，并可导出/导入 JSON 与现有执行器或历史版本对齐

### 4 关键交互/验证
- Alt+P 开启标注模式 → 鼠标移动即时高亮 → 点击收集节点信息。
- 侧边面板节点操作即时回传页面高亮，支持 Frame 切换与关键字搜索。
- 导出前运行唯一性预检，提示需手动复核的标注项；JSON 直接交付执行器校验。

### 5 设计目标
- 在真实页面内低侵入完成标注，保障高亮、采集与导出链路稳定。
- 为执行器提供稳定可维护的选择器候选，提高初始回放成功率。
- 保障大型复杂页面的交互性能，并预留 AI/自动化增强的接入接口。

## 模块二：用例→指令生成器（编译器）

### 1 输入
- TestRequest：自然语言用例描述 + 数据表（用来重复跑多次验证测试，比如要确认100个道具，每次确认需要在5个页面中跑流程，那需要提供100个道具的数据）。
- SiteProfile：页/元素/别名/边。

### TestRequest 自然语言用例描述 例：
```
用例名称：验证道具详情页展示内容

应用数据表中的数据，进行如下操作。
1. 访问 商城首页，用户名输入 xxx，密码输入 yyyy，点击登录
2. 在搜索栏中输入 道具名称，点击搜索
3. 断言：在 搜索结果页 中存在 道具名称与 输入道具名称完全相同的项目
4. 点击该项目
5. 断言：正确打开该道具的详情页
6. 断言：详情页中的道具图片没有缺失
7. 断言：详情页中的道具价格 与 道具表中的对应价格相同
```

### 2 输出：ActionPlan DSL（强类型）
- 整个输入是一个Action Plan目录
- 设想每一个测试用例是一个子目录
  - 有顺序
  - 每一个测试用例是一个完整的流程，用例和用例之间不支持交叉依赖
- ActionPlan 中的步骤携带可直接使用的 Playwright selector，执行器无需再读取 SiteProfile

#### 结构化任务描述
- 测试用例列表
  - 测试用例名
  - 测试数据清单（可选，如果要重复执行多次，验证不同数据的就需要）
  - 对应的ActionPlan DSL

#### ActionPlan DSL（强类型）
```
{
  "meta": {"testId": "TC-Checkout-001", "baseUrl": "https://shop.example.com"},
  "steps": [
    {"t":"goto",  "url":"/login"},
    {"t":"fill",  "selector":"data-test=login.email",    "value":"qa@example.com"},
    {"t":"fill",  "selector":"data-test=login.password", "value":"pass1234"},
    {"t":"click", "selector":"data-test=login.submit"},
    {"t":"goto",  "url":"/cart"},
    {"t":"assert","kind":"visible", "selector":"data-test=cart.heading"},
    {"t":"assert","kind":"text_regex", "selector":"data-test=cart.totalPrice","pattern":"^¥\\s?\\d+[.,]?\\d*$"}
  ]
}
```
- 如果有测试数据清单，则DSL中会有占位符

断言种类（建议内置）
- visible/invisible/enabled/disabled
- text_equals/text_contains/text_regex
- count_equals/count_at_least
- attr_equals/attr_contains
- http_ok（图片/资源响应 200）

### 3 约束与校验
- JSON Schema + 运行前静态校验（字段必填、selector 合法、URL 合法）。
- 编译阶段可用本地/外部模型

### 4 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署


## 模块三：测试执行器（Playwright）

### 1 行为
- 读取 ActionPlan目录，将Action Plan中的DSL和数据表（若有）进行组装
- 利用Playwright执行所有的Action Plan
- 不支持并发，必须按顺序执行

### 2 Trace & 工件
- 失败留证据策略：on-first-retry 或 retain-on-failure。
- 每次运行产出：
  - 带时间戳的结果文件夹
    - 每一个测试用例一个子结果文件夹
      - trace.zip、step 截图、console.log、network 摘要等
      - 结构化的测试报告（比如JSON，后续的数据项目为举例）：run_id、case_id、status、开始/结束、失败原因、trace 路径、关键指标。

### 3 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署
- 允许只执行部分用例，但用例不可再分割

### 4 错误处理
- 定位器 0 命中：截屏 + DOM 片段存档 + 提示最近似候选。
- 多命中：引导收紧定位（增加 hasText 等）。
- 网络失败：记录请求/响应摘要，支持重试/跳过策略。


## 模块四：结果/报告查看器

### 1 视图
- 输入结果文件夹
- 运行列表：按时间/用例/标签过滤，显示通过率、平均耗时、失败原因 TopN。
- 用例详情：步骤时间线、断言结果、截图缩略图、console/network 摘要。
- Trace 快捷入口：点击打开 trace.zip（调用本地 npx playwright show-trace 或嵌入静态 Viewer 页）。
- Profile 变更对比：展示本次运行引用的 Profile 版本与差异。

### 2 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署
- 这就是一个读取工具，将跨工具的结果放到一起方便用户查看
- 支持利用外部LLM综合分析，得出概要报告
