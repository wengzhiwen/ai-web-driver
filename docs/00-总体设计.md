# 总体描述

## 1 目标
- 免代码：QA 通过自然语言/表单即可编写用例。
- 低成本：运行期全本地；仅在“编译/标定”阶段按需使用外部 LLM。
- 可回放：失败可一键回溯（Trace Viewer），定位问题无需复现现场。
- 可维护：站点 Profile（页面/元素/别名/跳转条件）集中管理与版本化。

## 2 非目标（当前阶段）
- 不做“自治代理式”运行期决策（运行期不让 LLM 介入）。
- 不做跨站泛化爬测；只服务被测站点（白名单域）。

## 3 核心数据流
```
TestRequest(自然语言/DSL)
        │
        ├──[编译器/LLM]──► ActionPlan(强类型 DSL JSON)
        │
SiteProfile(标定/别名/定位器) 

ActionPlan ─────────► [执行器/Playwright MCP]
                                   │
                   Trace.zip + 运行明细(SQLite/Artifacts)
                                   │
                         [报告查看器/Trace Viewer]
```

## 4 关键技术选择
- 执行：Playwright。
- 标定：Playwright Inspector/Codegen + A11y 树 + axe 扫描。
- 模型：本地 7B（备用）；外部 LLM “辅助标定/用例编译”。
- 存储：SQLite / JSON文件（Profile/运行结果/工件索引）。

## 5 安全/合规
- Trace/日志：记录所有操作轨迹，便于问题回溯
- 数据隐私：本地存储，不涉及敏感数据外传
- 访问控制：仅限白名单域名访问

## 模块一：标定工具（Profile Builder）

### 1 核心功能
- 入口/发现：手动添加 URL；从读取的第一个页面开始，跟着操作一步步添加页面。
- 页面预览：在独立的 iframe 中加载页面，支持在DOM/A11y面板点选取元素后联动高亮（框选）。
- DOM/A11y 面板：展示可访问性树、关键属性（role/name/label/testId）。
- 自动标定草稿：
  - 通过 A11y axe 自动生成初稿
  - 结合 LLM/Codegen/Inspector 进行优化
- 手动精修：
  - 手动调整自动标定的结果（各项属性）
  - 隐藏指定的DOM（没有测试价值）
  - 添加自然语言描述
- 跳转关系：记录 edges（from→to），支持添加自然语言描述（因为是XXX类型，所以会跳转到YY）。
- 历史映射：加载历史 Profile，尝试匹配到当前 DOM，显示“✅匹配/⚠️模糊/❌失配”。
- 一键校验：验证每个 alias 的定位器是否唯一命中（count()==1），失败给出截图与建议。
- 自动二次标定：再次运行自动标定，最大限度保留手动精修的结果去匹配二次自动标定的结果
- 版本化：以页面为单位记录版本，以GMT+8时间戳作为版本号

### 2 SiteProfile
- 标定工具的核心输出是标定结果 SiteProfile
- SiteProfile是对被测试站点中的被测试对象页面的一系列描述
- 后续的编译器总是基于SiteProfile来对用户的自然语言用例描述进行处理（处理成Playwright指令和断言）
- SiteProfile是自带版本管理的，当SiteProfile中如果发生变化，与变化相关的页面及SiteProfile本身的版本号都会发生变化
- 隐藏操作会被准确的记录在SiteProfile的专门位置，被隐藏的DOM不会出现在SiteProfile的核心数据中，因为这些信息不需要被送给后续的编译器（编译器依赖LLM，送去的噪音越少越好）

### 3 SiteProfile的保存和调取
- SiteProfile应该被保存为结构化的JSON文件
- 标定工具可以保存SiteProfile也可以load一个已经存在的SiteProfile来继续/修改标定

### 4 关键交互/验证
- 拾取定位器：集成 Playwright Inspector/Codegen（点击目标→回填定位器）。
- 高亮联动：外部 DOM 面板选中元素 → iframe 内绘制遮罩框。
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署

### 5 设计目标
- 准确读取目标页面的所有DOM
- 自动标定解决80%的问题，且运行稳定（在LLM的加持下，多次运行的结果稳定性要高）

## 模块二：用例→指令生成器（编译器）

### 1 输入
- TestRequest：自然语言用例描述 + 数据表（用来重复跑多次验证测试，比如要确认100个道具，每次确认需要在5个页面中跑流程，那需要提供100个道具的数据）。
- SiteProfile：页/元素/别名/边。

### TestRequest 自然语言用例描述 例：
```
用例名称：验证道具详情页展示内容

应用数据表中的数据，进行如下操作。
1. 访问 商城首页，用户名输入 xxx，密码输入 yyyy，点击登录
2. 在搜索栏中输入 道具名称，点击搜索
3. 断言：在 搜索结果页 中存在 道具名称与 输入道具名称完全相同的项目
4. 点击该项目
5. 断言：正确打开该道具的详情页
6. 断言：详情页中的道具图片没有缺失
7. 断言：详情页中的道具价格 与 道具表中的对应价格相同
```

### 2 输出：ActionPlan DSL（强类型）
- 整个输入是一个Action Plan目录
- 设想每一个测试用例是一个子目录
  - 有顺序
  - 每一个测试用例是一个完整的流程，用例和用例之间不支持交叉依赖
- ActionPlan 中的步骤携带可直接使用的 Playwright selector，执行器无需再读取 SiteProfile

#### 结构化任务描述
- 测试用例列表
  - 测试用例名
  - 测试数据清单（可选，如果要重复执行多次，验证不同数据的就需要）
  - 对应的ActionPlan DSL

#### ActionPlan DSL（强类型）
```
{
  "meta": {"testId": "TC-Checkout-001", "baseUrl": "https://shop.example.com"},
  "steps": [
    {"t":"goto",  "url":"/login"},
    {"t":"fill",  "selector":"data-test=login.email",    "value":"qa@example.com"},
    {"t":"fill",  "selector":"data-test=login.password", "value":"pass1234"},
    {"t":"click", "selector":"data-test=login.submit"},
    {"t":"goto",  "url":"/cart"},
    {"t":"assert","kind":"visible", "selector":"data-test=cart.heading"},
    {"t":"assert","kind":"text_regex", "selector":"data-test=cart.totalPrice","pattern":"^¥\\s?\\d+[.,]?\\d*$"}
  ]
}
```
- 如果有测试数据清单，则DSL中会有占位符

断言种类（建议内置）
- visible/invisible/enabled/disabled
- text_equals/text_contains/text_regex
- count_equals/count_at_least
- attr_equals/attr_contains
- http_ok（图片/资源响应 200）

### 3 约束与校验
- JSON Schema + 运行前静态校验（字段必填、selector 合法、URL 合法）。
- 编译阶段可用本地/外部模型

### 4 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署


## 模块三：测试执行器（Playwright）

### 1 行为
- 读取 ActionPlan目录，将Action Plan中的DSL和数据表（若有）进行组装
- 利用Playwright执行所有的Action Plan
- 不支持并发，必须按顺序执行

### 2 Trace & 工件
- 失败留证据策略：on-first-retry 或 retain-on-failure。
- 每次运行产出：
  - 带时间戳的结果文件夹
    - 每一个测试用例一个子结果文件夹
      - trace.zip、step 截图、console.log、network 摘要等
      - 结构化的测试报告（比如JSON，后续的数据项目为举例）：run_id、case_id、status、开始/结束、失败原因、trace 路径、关键指标。

### 3 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署
- 允许只执行部分用例，但用例不可再分割

### 4 错误处理
- 定位器 0 命中：截屏 + DOM 片段存档 + 提示最近似候选。
- 多命中：引导收紧定位（增加 hasText 等）。
- 网络失败：记录请求/响应摘要，支持重试/跳过策略。


## 模块四：结果/报告查看器

### 1 视图
- 输入结果文件夹
- 运行列表：按时间/用例/标签过滤，显示通过率、平均耗时、失败原因 TopN。
- 用例详情：步骤时间线、断言结果、截图缩略图、console/network 摘要。
- Trace 快捷入口：点击打开 trace.zip（调用本地 npx playwright show-trace 或嵌入静态 Viewer 页）。
- Profile 变更对比：展示本次运行引用的 Profile 版本与差异。

### 2 关键交互/验证
- 利用本地的python + flask运行，工具本身完全HTML化、REST化；不考虑部署
- 这就是一个读取工具，将跨工具的结果放到一起方便用户查看
- 支持利用外部LLM综合分析，得出概要报告
